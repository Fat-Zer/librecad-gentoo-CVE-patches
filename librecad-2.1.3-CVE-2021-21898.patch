Origin: https://sources.debian.org/patches/librecad/2.1.3-3/CVE-2021-21898.patch/
Bug: https://bugs.gentoo.org/825362

From ba3fa95648bef948e008dfbdd31a4d21badd71f0 Mon Sep 17 00:00:00 2001
From: Armin Stebich <home@mail.lordofbikes.de>
Date: Sun, 31 Oct 2021 21:35:24 +0100
Subject: [PATCH] fixed out-of-bounds write vulnerability CVE-2021-21898

as reported in TALOS-2021-1349 / CVE-2021-21898,
dwgCompressor::decompress18() could be abused with a malformed DWG file
to force out-of-bounds write and possibly lead to malicious code
execution.
---
 src/intern/dwgreader18.cpp |  21 ++++--
 src/intern/dwgreader18.h   |   2 +-
 src/intern/dwgutil.cpp     | 142 +++++++++++++++++++++++--------------
 src/intern/dwgutil.h       |  17 +++--
 4 files changed, 120 insertions(+), 62 deletions(-)

Index: librecad-2.1.2/libraries/libdxfrw/src/intern/dwgreader18.cpp
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/intern/dwgreader18.cpp
+++ librecad-2.1.2/libraries/libdxfrw/src/intern/dwgreader18.cpp
@@ -67,7 +67,7 @@ duint32 dwgReader18::checksum(duint32 se
 }
 
  //called: Section page map: 0x41630e3b
-void dwgReader18::parseSysPage(duint8 *decompSec, duint32 decompSize){
+bool dwgReader18::parseSysPage(duint8 *decompSec, duint32 decompSize){
     DRW_DBG("\nparseSysPage:\n ");
     duint32 compSize = fileBuf->getRawLong32();
     DRW_DBG("Compressed size= "); DRW_DBG(compSize); DRW_DBG(", "); DRW_DBGH(compSize);
@@ -95,7 +95,10 @@ void dwgReader18::parseSysPage(duint8 *d
 #endif
     DRW_DBG("decompresing "); DRW_DBG(compSize); DRW_DBG(" bytes in "); DRW_DBG(decompSize); DRW_DBG(" bytes\n");
     dwgCompressor comp;
-	comp.decompress18(tmpCompSec.data(), decompSec, compSize, decompSize);
+    if (!comp.decompress18(tmpCompSec.data(), decompSec, compSize, decompSize)) {
+        return false;
+    }
+
 #ifdef DRW_DBG_DUMP
     for (unsigned int i=0, j=0; i< decompSize;i++) {
         DRW_DBGH( decompSec[i]);
@@ -103,6 +106,8 @@ void dwgReader18::parseSysPage(duint8 *d
         } else { DRW_DBG(", "); j++; }
     } DRW_DBG("\n");
 #endif
+
+    return true;
 }
 
  //called ???: Section map: 0x4163003b
@@ -165,7 +170,9 @@ bool dwgReader18::parseDataPage(dwgSecti
         pi.uSize = si.maxSize;
         DRW_DBG("decompresing "); DRW_DBG(pi.cSize); DRW_DBG(" bytes in "); DRW_DBG(pi.uSize); DRW_DBG(" bytes\n");
         dwgCompressor comp;
-		comp.decompress18(cData.data(), oData, pi.cSize, pi.uSize);
+        if (!comp.decompress18(cData.data(), oData, pi.cSize, pi.uSize)) {
+            return false;
+        }
     }
     return true;
 }
@@ -302,7 +309,9 @@ bool dwgReader18::readFileHeader() {
         return false;
     }
 	std::vector<duint8> tmpDecompSec(decompSize);
-	parseSysPage(tmpDecompSec.data(), decompSize);
+    if (!parseSysPage(tmpDecompSec.data(), decompSize)) {
+        return false;
+    }
 
 //parses "Section page map" decompresed data
 	dwgBuffer buff2(tmpDecompSec.data(), decompSize, &decoder);
@@ -344,7 +353,9 @@ bool dwgReader18::readFileHeader() {
         return false;
     }
 	tmpDecompSec.resize(decompSize);
-	parseSysPage(tmpDecompSec.data(), decompSize);
+    if (!parseSysPage(tmpDecompSec.data(), decompSize)) {
+        return false;
+    }
 
 //reads sections:
     DRW_DBG("\n*** dwgReader18: reads sections:");
Index: librecad-2.1.2/libraries/libdxfrw/src/intern/dwgreader18.h
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/intern/dwgreader18.h
+++ librecad-2.1.2/libraries/libdxfrw/src/intern/dwgreader18.h
@@ -81,7 +81,7 @@ protected:
 private:
     void genMagicNumber();
 //    dwgBuffer* bufObj;
-    void parseSysPage(duint8 *decompSec, duint32 decompSize); //called: Section page map: 0x41630e3b
+    bool parseSysPage(duint8 *decompSec, duint32 decompSize); //called: Section page map: 0x41630e3b
     bool parseDataPage(dwgSectionInfo si/*, duint8 *dData*/); //called ???: Section map: 0x4163003b
     duint32 checksum(duint32 seed, duint8* data, duint32 sz);
 
Index: librecad-2.1.2/libraries/libdxfrw/src/intern/dwgutil.cpp
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/intern/dwgutil.cpp
+++ librecad-2.1.2/libraries/libdxfrw/src/intern/dwgutil.cpp
@@ -87,18 +87,18 @@ void dwgRSCodec::decode251I(unsigned cha
 
 duint32 dwgCompressor::twoByteOffset(duint32 *ll){
     duint32 cont = 0;
-    duint8 fb = bufC[pos++];
-    cont = (fb >> 2) | (bufC[pos++] << 6);
+    duint8 fb = compressedByte();
+    cont = (fb >> 2) | (compressedByte() << 6);
     *ll = (fb & 0x03);
     return cont;
 }
 
 duint32 dwgCompressor::longCompressionOffset(){
     duint32 cont = 0;
-    duint8 ll = bufC[pos++];
-    while (ll == 0x00){
+    duint8 ll = compressedByte();
+    while (ll == 0x00 && compressedGood) {
         cont += 0xFF;
-        ll = bufC[pos++];
+        ll = compressedByte();
     }
     cont += ll;
     return cont;
@@ -107,60 +107,58 @@ duint32 dwgCompressor::longCompressionOf
 duint32 dwgCompressor::long20CompressionOffset(){
 //    duint32 cont = 0;
     duint32 cont = 0x0F;
-    duint8 ll = bufC[pos++];
-    while (ll == 0x00){
+    duint8 ll = compressedByte();
+    while (ll == 0x00 && compressedGood){
 //        cont += 0xFF;
-        ll = bufC[pos++];
+        ll = compressedByte();
     }
     cont += ll;
     return cont;
 }
 
 duint32 dwgCompressor::litLength18(){
-    duint32 cont=0;
-    duint8 ll = bufC[pos++];
+    duint32 cont = 0;
+    duint8 ll = compressedByte();
     //no literal length, this byte is next opCode
     if (ll > 0x0F) {
-        pos--;
+        --compressedPos;
         return 0;
     }
 
     if (ll == 0x00) {
         cont = 0x0F;
-        ll = bufC[pos++];
-        while (ll == 0x00){//repeat until ll != 0x00
-            cont +=0xFF;
-            ll = bufC[pos++];
+        ll = compressedByte();
+        while (ll == 0x00 && compressedGood) {//repeat until ll != 0x00
+            cont += 0xFF;
+            ll = compressedByte();
         }
     }
-    cont +=ll;
-    cont +=3; //already sum 3
-    return cont;
+
+    return cont + ll + 3;
 }
 
-void dwgCompressor::decompress18(duint8 *cbuf, duint8 *dbuf, duint32 csize, duint32 dsize){
-    bufC = cbuf;
-    bufD = dbuf;
-    sizeC = csize -2;
-    sizeD = dsize;
+bool dwgCompressor::decompress18(duint8 *cbuf, duint8 *dbuf, duint64 csize, duint64 dsize){
+    compressedBuffer = cbuf;
+    decompBuffer = dbuf;
+    compressedSize = csize;
+    decompSize = dsize;
+    compressedPos=0; //current position in compressed buffer
+    decompPos=0; //current position in resulting decompressed buffer
+
     DRW_DBG("dwgCompressor::decompress, last 2 bytes: ");
-    DRW_DBGH(bufC[sizeC]);DRW_DBGH(bufC[sizeC+1]);DRW_DBG("\n");
-    sizeC = csize;
+    DRW_DBGH(compressedBuffer[compressedSize - 2]);DRW_DBG(" ");DRW_DBGH(compressedBuffer[compressedSize - 1]);DRW_DBG("\n");
 
-    duint32 compBytes;
-    duint32 compOffset;
-    duint32 litCount;
-
-    pos=0; //current position in compresed buffer
-    rpos=0; //current position in resulting decompresed buffer
-    litCount = litLength18();
-    //copy first lileral lenght
-    for (duint32 i=0; i < litCount; ++i) {
-        bufD[rpos++] = bufC[pos++];
+    duint32 compBytes {0};
+    duint32 compOffset {0};
+    duint32 litCount {litLength18()};
+
+    //copy first literal length
+    for (duint32 i = 0; i < litCount && buffersGood(); ++i) {
+        decompSet( compressedByte());
     }
 
-    while (pos < csize && (rpos < dsize+1)){//rpos < dsize to prevent crash more robust are needed
-        duint8 oc = bufC[pos++]; //next opcode
+    while (buffersGood()) {
+        duint8 oc = compressedByte(); //next opcode
         if (oc == 0x10){
             compBytes = longCompressionOffset()+ 9;
             compOffset = twoByteOffset(&litCount) + 0x3FFF;
@@ -176,8 +174,6 @@ void dwgCompressor::decompress18(duint8
             compOffset = twoByteOffset(&litCount);
             if (litCount == 0)
                 litCount= litLength18();
-//            else
-//                oc = 0x00;
         } else if (oc > 0x20 && oc< 0x40){
             compBytes = oc - 0x1E;
             compOffset = twoByteOffset(&litCount);
@@ -185,38 +181,85 @@ void dwgCompressor::decompress18(duint8
                 litCount= litLength18();
         } else if ( oc > 0x3F){
             compBytes = ((oc & 0xF0) >> 4) - 1;
-            duint8 ll2 = bufC[pos++];
+            duint8 ll2 = compressedByte();
             compOffset =  (ll2 << 2) | ((oc & 0x0C) >> 2);
             litCount = oc & 0x03;
             if (litCount < 1){
                 litCount= litLength18();}
         } else if (oc == 0x11){
             DRW_DBG("dwgCompressor::decompress, end of input stream, Cpos: ");
-            DRW_DBG(pos);DRW_DBG(", Dpos: ");DRW_DBG(rpos);DRW_DBG("\n");
-            return; //end of input stream
+            DRW_DBG(compressedPos);DRW_DBG(", Dpos: ");DRW_DBG(decompPos);DRW_DBG("\n");
+            return true; //end of input stream
         } else { //ll < 0x10
-            DRW_DBG("WARNING dwgCompressor::decompress, failed, illegal char, Cpos: ");
-            DRW_DBG(pos);DRW_DBG(", Dpos: ");DRW_DBG(rpos);DRW_DBG("\n");
-            return; //fails, not valid
-        }
-        //copy "compresed data", TODO Needed verify out of bounds
-        duint32 remaining = sizeD - (litCount+rpos);
-        if (remaining < compBytes){
-            compBytes = remaining;
-            DRW_DBG("WARNING dwgCompressor::decompress, bad compBytes size, Cpos: ");
-            DRW_DBG(pos);DRW_DBG(", Dpos: ");DRW_DBG(rpos);DRW_DBG("\n");
-        }
-        for (duint32 i=0, j= rpos - compOffset -1; i < compBytes; i++) {
-            bufD[rpos++] = bufD[j++];
-        }
-        //copy "uncompresed data", TODO Needed verify out of bounds
-        for (duint32 i=0; i < litCount; i++) {
-            bufD[rpos++] = bufC[pos++];
+            DRW_DBG("WARNING dwgCompressor::decompress, failed, illegal char: "); DRW_DBGH(oc);
+            DRW_DBG(", Cpos: "); DRW_DBG(compressedPos);
+            DRW_DBG(", Dpos: "); DRW_DBG(decompPos); DRW_DBG("\n");
+            return false; //fails, not valid
+        }
+
+        //copy "compressed data", if size allows
+        if (decompSize < decompPos + compBytes) {
+            DRW_DBG("WARNING dwgCompressor::decompress18, bad compBytes size, Cpos: ");
+            DRW_DBG(compressedPos);DRW_DBG(", Dpos: ");DRW_DBG(decompPos);DRW_DBG(", need ");DRW_DBG(compBytes);DRW_DBG(", available ");DRW_DBG(decompSize - decompPos);DRW_DBG("\n");
+            // only copy what we can fit
+            compBytes = decompSize - decompPos;
+        }
+        duint32 j {decompPos - compOffset - 1};
+        for (duint32 i = 0; i < compBytes && buffersGood(); i++) {
+            decompSet( decompByte( j++));
+        }
+
+        //copy "uncompressed data", if size allows
+        if (decompSize < decompPos + litCount) {
+            DRW_DBG("WARNING dwgCompressor::decompress18, bad litCount size, Cpos: ");
+            DRW_DBG(compressedPos);DRW_DBG(", Dpos: ");DRW_DBG(decompPos);DRW_DBG(", need ");DRW_DBG(litCount);DRW_DBG(", available ");DRW_DBG(decompSize - decompPos);DRW_DBG("\n");
+            // only copy what we can fit
+            litCount = decompSize - decompPos;
+        }
+        for (duint32 i=0; i < litCount && buffersGood(); i++) {
+            decompSet( compressedByte());
         }
     }
-    DRW_DBG("WARNING dwgCompressor::decompress, bad out, Cpos: ");DRW_DBG(pos);DRW_DBG(", Dpos: ");DRW_DBG(rpos);DRW_DBG("\n");
+
+    DRW_DBG("WARNING dwgCompressor::decompress, bad out, Cpos: ");DRW_DBG(compressedPos);DRW_DBG(", Dpos: ");DRW_DBG(decompPos);DRW_DBG("\n");
+    return false;
 }
 
+duint32 dwgCompressor::compressedByte(void)
+{
+    duint32 result {0};
+
+    compressedGood = (compressedPos < compressedSize);
+    if (compressedGood) {
+        result = compressedBuffer[compressedPos];
+        ++compressedPos;
+    }
+
+    return result;
+}
+
+duint32 dwgCompressor::decompByte(const duint32 index)
+{
+    if (index < decompSize) {
+        return decompBuffer[index];
+    }
+
+    return 0;
+}
+
+void dwgCompressor::decompSet(const duint8 value)
+{
+    decompGood = (decompPos < decompSize);
+    if (decompGood) {
+        decompBuffer[decompPos] = value;
+        ++decompPos;
+    }
+}
+
+bool dwgCompressor::buffersGood(void)
+{
+    return compressedGood && decompGood;
+}
 
 void dwgCompressor::decrypt18Hdr(duint8 *buf, duint32 size, duint32 offset){
     duint8 max = size / 4;
Index: librecad-2.1.2/libraries/libdxfrw/src/intern/dwgutil.h
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/intern/dwgutil.h
+++ librecad-2.1.2/libraries/libdxfrw/src/intern/dwgutil.h
@@ -27,7 +27,7 @@ void decode251I(duint8 *in, duint8 *out,
 class dwgCompressor {
 public:
 
-    void decompress18(duint8 *cbuf, duint8 *dbuf, duint32 csize, duint32 dsize);
+    bool decompress18(duint8 *cbuf, duint8 *dbuf, duint64 csize, duint64 dsize);
     static void decrypt18Hdr(duint8 *buf, duint32 size, duint32 offset);
 //    static void decrypt18Data(duint8 *buf, duint32 size, duint32 offset);
     static void decompress21(duint8 *cbuf, duint8 *dbuf, duint32 csize, duint32 dsize);
@@ -42,13 +42,19 @@ private:
     duint32 long20CompressionOffset();
     duint32 twoByteOffset(duint32 *ll);
 
-    duint8 *bufC;
-    duint8 *bufD;
-    duint32 sizeC;
-    duint32 sizeD;
-    duint32 pos;
-    duint32 rpos;
-
+    duint32 compressedByte(void);
+    duint32 decompByte(const duint32 index);
+    void decompSet(const duint8 value);
+    bool buffersGood(void);
+
+    duint8 *compressedBuffer {nullptr};
+    duint32 compressedSize {0};
+    duint32 compressedPos {0};
+    bool    compressedGood {true};
+    duint8 *decompBuffer {nullptr};
+    duint32 decompSize {0};
+    duint32 decompPos {0};
+    bool    decompGood {true};
 };
 
 namespace secEnum {
