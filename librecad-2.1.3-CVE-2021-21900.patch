Origin: https://sources.debian.org/patches/librecad/2.1.3-3/CVE-2021-21900.patch/
Bug: https://bugs.gentoo.org/825362

From fcd977cc7f8f6cc7f012e5b72d33cf7d77b3fa69 Mon Sep 17 00:00:00 2001
From: Armin Stebich <home@mail.lordofbikes.de>
Date: Wed, 10 Nov 2021 16:40:17 +0100
Subject: [PATCH] fixed heap use after free vulnerability CVE-2021-21900

as reported in TALOS-2021-1351 / CVE-2021-21900,
DRW_TableEntry::parseCode had the potential to trigger an use after free exception with a malformed DXF file.
---
 src/drw_objects.cpp | 31 ++++++++++++++-----
 src/drw_objects.h   | 75 +++++++++++++++++++++++----------------------
 2 files changed, 63 insertions(+), 43 deletions(-)

Index: librecad-2.1.2/libraries/libdxfrw/src/drw_objects.cpp
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/drw_objects.cpp
+++ librecad-2.1.2/libraries/libdxfrw/src/drw_objects.cpp
@@ -50,23 +50,40 @@ void DRW_TableEntry::parseCode(int code,
     case 1011:
     case 1012:
     case 1013:
-        curr = new DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));
-        extData.push_back(curr);
+        // don't trust in X, Y, Z order!
+        if (nullptr != curr) {
+            curr->setCoordX( reader->getDouble());
+        }
+        else {
+            curr = new DRW_Variant( code, DRW_Coord( reader->getDouble(), 0.0, 0.0));
+            extData.push_back(curr);
+        }
         break;
     case 1020:
     case 1021:
     case 1022:
     case 1023:
-        if (curr)
-            curr->setCoordY(reader->getDouble());
+        // don't trust in X, Y, Z order!
+        if (nullptr != curr) {
+            curr->setCoordY( reader->getDouble());
+        }
+        else {
+            curr = new DRW_Variant( code, DRW_Coord( 0.0, reader->getDouble(), 0.0));
+            extData.push_back(curr);
+        }
         break;
     case 1030:
     case 1031:
     case 1032:
     case 1033:
-        if (curr)
-            curr->setCoordZ(reader->getDouble());
-        curr=NULL;
+        // don't trust in X, Y, Z order!
+        if (nullptr != curr) {
+            curr->setCoordZ( reader->getDouble());
+        }
+        else {
+            curr = new DRW_Variant( code, DRW_Coord( 0.0, 0.0, reader->getDouble()));
+            extData.push_back(curr);
+        }
         break;
     case 1040:
     case 1041:
Index: librecad-2.1.2/libraries/libdxfrw/src/drw_objects.h
===================================================================
--- librecad-2.1.2.orig/libraries/libdxfrw/src/drw_objects.h
+++ librecad-2.1.2/libraries/libdxfrw/src/drw_objects.h
@@ -55,33 +55,34 @@ namespace DRW {
 */
 class DRW_TableEntry {
 public:
-    //initializes default values
-    DRW_TableEntry() {
-        tType = DRW::UNKNOWNT;
-        flags = 0;
-        numReactors = xDictFlag = 0;
-        parentHandle = 0;
-        curr = NULL;
-    }
+
+    DRW_TableEntry() {}
 
     virtual~DRW_TableEntry() {
-        for (std::vector<DRW_Variant*>::iterator it=extData.begin(); it!=extData.end(); ++it)
+        for (std::vector<DRW_Variant*>::iterator it = extData.begin(); it != extData.end(); ++it) {
             delete *it;
+        }
 
         extData.clear();
     }
 
-    DRW_TableEntry(const DRW_TableEntry& e) {
-        tType = e.tType;
-        handle = e.handle;
-        parentHandle = e.parentHandle;
-        name = e.name;
-        flags = e.flags;
-        numReactors = e.numReactors;
-        xDictFlag = e.xDictFlag;
-        curr = e.curr;
-        for (std::vector<DRW_Variant*>::const_iterator it=e.extData.begin(); it!=e.extData.end(); ++it){
-            extData.push_back(new DRW_Variant(*(*it)));
+    DRW_TableEntry(const DRW_TableEntry& e) :
+        tType {e.tType},
+        handle {e.handle},
+        parentHandle {e.parentHandle},
+        name {e.name},
+        flags {e.flags},
+        xDictFlag {e.xDictFlag},
+        numReactors {e.numReactors},
+        curr {nullptr}
+    {
+        for (std::vector<DRW_Variant *>::const_iterator it = e.extData.begin(); it != e.extData.end(); ++it) {
+            DRW_Variant *src = *it;
+            DRW_Variant *dst = new DRW_Variant( *src);
+            extData.push_back( dst);
+            if (src == e.curr) {
+                curr = dst;
+            }
         }
     }
 
@@ -89,30 +90,32 @@ protected:
     void parseCode(int code, dxfReader *reader);
     virtual bool parseDwg(DRW::Version version, dwgBuffer *buf, duint32 bs=0) = 0;
     bool parseDwg(DRW::Version version, dwgBuffer *buf, dwgBuffer* strBuf, duint32 bs=0);
-    void reset(){
-        flags =0;
-        for (std::vector<DRW_Variant*>::iterator it=extData.begin(); it!=extData.end(); ++it)
+    void reset() {
+        flags = 0;
+        for (std::vector<DRW_Variant*>::iterator it = extData.begin(); it != extData.end(); ++it) {
             delete *it;
+        }
         extData.clear();
+        curr = nullptr;
     }
 
 public:
-    enum DRW::TTYPE tType;     /*!< enum: entity type, code 0 */
-    duint32 handle;            /*!< entity identifier, code 5 */
-    int parentHandle;          /*!< Soft-pointer ID/handle to owner object, code 330 */
-    UTF8STRING name;           /*!< entry name, code 2 */
-    int flags;                 /*!< Flags relevant to entry, code 70 */
-    std::vector<DRW_Variant*> extData; /*!< FIFO list of extended data, codes 1000 to 1071*/
-
-private:
-    DRW_Variant* curr;
+    enum DRW::TTYPE tType {DRW::UNKNOWNT};  /*!< enum: entity type, code 0 */
+    duint32         handle {0};             /*!< entity identifier, code 5 */
+    int             parentHandle {0};       /*!< Soft-pointer ID/handle to owner object, code 330 */
+    UTF8STRING      name;                   /*!< entry name, code 2 */
+    int             flags {0};              /*!< Flags relevant to entry, code 70 */
+    std::vector<DRW_Variant*> extData;      /*!< FIFO list of extended data, codes 1000 to 1071*/
 
     //***** dwg parse ********/
 protected:
-    dint16 oType;
-    duint8 xDictFlag;
-    dint32 numReactors; //
-    duint32 objSize;  //RL 32bits object data size in bits
+    dint16  oType {0};
+    duint8  xDictFlag {0};
+    dint32  numReactors {0};
+    duint32 objSize {0};    //RL 32bits object data size in bits
+
+private:
+    DRW_Variant* curr {nullptr};
 };
 
 
